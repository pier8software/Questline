schema: spec-driven

context: |
    ## Project Identity
    Questline is a parser-driven text adventure engine built in C# (.NET 10).
    Long-term vision: cooperative MUD platform. Development follows an incremental
    roadmap starting with a single-player 5-room dungeon (Phase 0).

    ## Tech Stack
    - Runtime: .NET 10 (LTS)
    - Serialisation: System.Text.Json
    - DI: Microsoft.Extensions.DependencyInjection
    - Testing: xUnit + Shouldly (behavioural, test-first)
    - Console output: Console.WriteLine (Phase 0)
    - Monorepo, single app project with namespace separation

    ## Architecture
    Four namespaces with inward dependency flow:
    - Questline.Cli — entry point, game loop, terminal I/O, DI composition root
    - Questline.Domain — entities, value objects, game rules (NO dependencies on other namespaces)
    - Questline.Engine — parser, command dispatcher, command handlers, event generation
    - Questline.Framework — JSON serialisation, save/load, content loading, messaging

    Command pipeline: Input -> Parser -> Command -> Handler -> Event/Result -> Renderer
    Handlers receive command objects, return results (never write to console directly).
    Handlers registered with dispatcher by verb using registration pattern.

    ## Code Style
    - File-scoped namespaces, primary constructors, prefer records for immutable data
    - PascalCase public members/types, camelCase private fields
    - Entities have identity (required string Id), value objects use records
    - Allman brace style
    - Content defined in JSON, not code

    ## Testing
    - use xUnit + Shouldly and write tests BEFORE implementation
    - Test name convention: Plain English, fact-based naming: Write test names as clear, declarative statements that describe behavior from a business perspective.
    - Example test name: `Delivery_with_a_past_date_is_invalid()`
    - Use class names to represent the subject and method names to describe scenarios, improving readability and grouping.
    - Example test class:
    ```
    public class BankAccountTests
    {
        [Fact]
        public void Has_balance_of_zero_when_created() { /* ... */ }

        [Fact]
        public void Has_balance_increased_after_a_deposit() { /* ... */ }
    }
    ```

    ## Git Workflow
    - Trunk-based development, short-lived feature branches
    - Rebase only, squash merge on PR
    - CI: build + test on every PR

    ## Roadmap Status
    Implemented (Phase 0):
    -   0.1 Scaffolding: world model, room graph, look/go commands, game loop, quit
    -   0.2 Items & Inventory: Item entity, Inventory container, get/drop/inventory commands
    -   0.3 Content Loading: JSON adventure files, loader, validation, 5-room dungeon

    Planned (Phase 0):
    -   0.4 Puzzles: use command, barriers, examine, room features
    -   0.5 Character Creation: name entry, default Human Fighter, stats command
    -   0.6 Save/Load: persist and restore game state
    -   0.7 Polish: help system, error handling, victory detection, command shortcuts

    Future phases: Solo Adventure (combat, XP), Party Play (networking), MUD Platform.

    ## Phase 0 Scope Boundaries
    Out of scope: combat/enemies, NPCs with dialogue, multiplayer/networking,
    progression (XP, levelling, shops), Terminal.Gui or TUI frameworks.

    ## Domain Structure
    `Domain/` is organised by feature: `Players/`, `Rooms/`, `Shared/`.
    Each feature folder uses the same internal layout:
    - `Entity/` — domain entities and value objects (e.g. `Player`, `Room`, `Item`)
    - `Data/` — data-transfer objects for JSON deserialisation (where applicable)
    `Shared/` holds cross-cutting concerns: `Item`, `Inventory`, `GameState`, `AdventureData`.
    New features get their own top-level folder under `Domain/` following this layout.

    ## Command Pipeline Details
    Adding a new command follows a mediator pattern:
    - **Request**: a record implementing `IRequest` with `static abstract CreateRequest(string[] args)`.
      Decorated with `[Verbs("verb", "alias")]` for parser discovery.
    - **Response**: a record implementing `IResponse` (`string Message` property).
      Use static factory methods for success/error construction.
    - **Handler**: a class implementing `IRequestHandler<TRequest>`.
      Method signature: `IResponse Handle(GameState state, TRequest request)`.
    - **Registration**: one line in `Engine/ServiceCollectionExtensions.RegisterCommandHandlers()`:
      `services.AddSingleton<IRequestHandler<MyCommand>, MyCommandHandler>();`
    - **Parser discovery**: `Engine/InputParsers/Parser` uses reflection to find all `IRequest`
      types with `[Verbs]` at startup — no manual routing required.
    - **Dispatch**: `Framework/Mediator/RequestSender` resolves the correct handler via DI
      and invokes `Handle()`.

    ## Test Helpers
    - `GameBuilder` — fluent builder: `.WithRoom(id, name, desc, r => r.WithExit(...).WithItem(...))`
    - `RoomBuilder` — configures exits and items for a single room
    - `FakeConsole` — implements `IConsole` for integration tests (queue input, capture output)
    - Test namespaces mirror source: `Questline.Tests.<Layer>.<Feature>.Handlers`

    ## New Feature Checklist
    1. Create request record with `[Verbs]` in `Engine/Messages/Requests.cs`
    2. Create response record with factory methods in `Engine/Messages/Responses.cs`
    3. Create handler implementing `IRequestHandler<T>` in `Engine/Handlers/`
    4. Register handler in `Engine/ServiceCollectionExtensions.RegisterCommandHandlers()`
    5. Write tests using `GameBuilder`/`RoomBuilder` in `tests/Questline.Tests/Engine/Handlers/`

rules:
    spec:
        - Use SHALL for requirements (e.g. "The parser SHALL tokenise input")
        - Every requirement MUST have at least one WHEN/THEN scenario
        - Implemented specs describe requirements only — code is the source of truth
        - Planned specs include an Implementation Notes section with key models and patterns
    proposal:
        - Reference the relevant spec by name
        - Keep proposals under 500 words
        - Include a Non-goals section
    tasks:
        - Each task should be completable in a single session
        - Include the test to write before the production code
    delta-spec:
        - Only include requirements that are new or changed
        - Reference existing spec requirements by name when unchanged
